<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../css/main.css">
    <title>EZB - mollusk</title>
  </head>
  <body>
    <a id="home" href="../../thoughts.html">‚Üê</a>
    <div id="maindivalt">
      <div id="title">
        Mollusk
        <div id="subtitle">
          üê† + üêö = üåà
        </div>
      </div>
      <h1> Prelude </h1>
      <h2> Learning to Fish </h2>
      As soon as I found out that there were different shells, I went looking
      for something better than bash. Bash is fine and all, but once you see
      the features alternative shells offer, you'll never switch back.
      <br>
      <br>
      The <a href="https://fishshell.com">fish shell</a> was one of the first
      shells I found, and it was the last shell I thought I needed. Everything
      was so <i>fast</i>. I felt like it knew what I was going to do,
      before I even knew what I was going to do. It's autocomplete is
      fantastic, the way it fuzzily suggests the directory you meant to cd
      into, the deduplication of history, the simpler syntax, etc... all of
      that, made fish a pleasure to use.
      <br>
      <br>
      This doesn't speak to any error on fish's part but, I often found myself
      pulling up the <a href="https://www.python.org/">Python</a> REPL to do
      some quick functions or math expressions. Stuff like this was pretty
      common:
      <br>
      <br>
      <div class="code">
        ezb <ezb-import>~</ezb-import>&gt; python3<br>
        Python 3.7.0<br><br>
        &gt;&gt;&gt; <ezb-num>0x113e8b3</ezb-num><br>
        <ezb-num>18081971</ezb-num><br>
        &gt;&gt;&gt; <ezb-num>719</ezb-num> <ezb-op>*</ezb-op>
          <ezb-num>114679</ezb-num><br>
        <ezb-num>82454201</ezb-num>
      </div>
      <br>
      So much so that I sometimes even tried running numerical operations
      like these on the fish shell itself on accident,
      <br>
      <br>
      <div class="code">
        ezb <ezb-import>~</ezb-import>&gt; <ezb-str>123</ezb-str>
          <ezb-num>* 12</ezb-num><br>
        fish: Unknown command '123'
      </div>
      <br>
      I tried to faithfully reproduce fish's syntax highlighting for a
      situation like this. After accidentally doing this a few times, I
      eventually thought to myself:
      &ldquo;why <i>shouldn't</i> this work?&rdquo; I mean, it seems simple
      enough, just capture stuff that is a valid arithmetic expression and
      then run it as Python! But then I thought about variables, and how I
      would handle those, what about tuples, or lambdas, or... At this point
      I realized that I'd have to capture the entire Python grammar. Through
      some weird chain of Google queries, I eventually just looked up &ldquo;
      Python as a shell&rdquo;, and quickly found myself a
      <a href="http://xonsh.org/">xonsh</a>.

      <h2> Xonsh </h2>
      Xonsh blew my mind. Xonsh is essentially a superset of Python 3+ syntax
      that includes bash-like shell primitives. The entire shell can be
      treated like a Python REPL. The environment variables are
      Python objects. Need to add something to your path, no problem! Just
      type <ezb-code>$PATH.append("~/new/path/")</ezb-code>. Need to add an
      alias? Just type <ezb-code>aliases["ll"] = "ls -l"</ezb-code>.
      The benefits of this were huge and I felt much more at home with this
      shell.  Since it was all Python, modifying anything was as easy as
      manipulating a Python object. But of course, it wasn't perfect...
      <br>
      <br>
      The autocomplete was nowhere near as nice as fish's. The tab-suggestions
      that xonsh would give were always pretty bad. Something like this would
      often happen.
      <br>
      <br>
      <div class="code">
        ezb <ezb-import>~</ezb-import>&gt; ls <br>
        &nbsp;&nbsp;lab1.hs <br>
        ezb <ezb-import>~</ezb-import>&gt; vim lab1.hs <br>
        &nbsp;&nbsp;...do some stuff here... <br>
        ezb <ezb-import>~</ezb-import>&gt; mv lab1.hs lab2.hs <br>
        &nbsp;&nbsp;...do some stuff here... <br>
        ezb <ezb-import>~</ezb-import>&gt; vim lab|<ezb-str>1.hs<ezb-str> <br>
      </div>
      <br>
      The <ezb-code>|</ezb-code> represents the cursor, and the red text after
      it represents the erroneous suggestion. This happened all the damn time,
      and I despised it. Any command that previously ran on a file, would
      have that file autosuggested, even if that file was clearly not
      there anymore. I modified xonsh a bunch to not have this behavior,
      but the tab-completer still always looked through the history, even
      if the auto-suggestions didn't. Fish did not have this behavior, it
      always would suggest a file that existed if the previous command
      succeeded with a command-line argument that referred to a file.
      <br>
      <br>
      I wondered if there was a way to combine xonsh and fish, in a way that
      kept the best parts of both of them. Ideally, this would be a shell
      that acted exactly like xonsh, except for the autocompletion portion,
      which would act like fish. It should also be indistinguishable from
      xonsh to a running process. Could something like this exist...

      <div id="footer-links">
        <ul>
          <li><a href="../../thoughts.html">Thoughts</a></li>
        </ul>
      </div>

    </div>
    <script>
      renderMathInElement(
        document.body,
        {
          delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false},
          ]
        }
      );
    </script>
  </body>
</html>
